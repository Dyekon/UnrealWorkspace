# UnrealSerialization

## 1. 직렬화
오브젝트나 연결된 오브젝트의 묶음을 바이트 스트림으로 변환하는 과정
- 복잡한 데이터를 일렬로 세우기 때문에 직렬화라고 불림
 
- 시리얼라이제이션(Serialization) : 오브젝트 그래프 -> 바이트 스트림
- 디시리얼라이제이션(DeSerialization) : 바이트 스트림 -> 오브젝트 그래프

-현재 프로그램의 상태를 필요할 때 저장 및 복원 가능(게임의 저장기능) </br>
-현재 객체의 정보를 클립보드에 복사 후 다른 프로그램으로 전송 가능 </br>
-네트워크를 통해 현재 프로그램의 상태를 다른 컴퓨터에 복원할 수 있음(멀티플레이어 게임) </br>
-데이터 압축, 암호화가 가능하여 데이터을 효율적이고 안전하게 보관 가능 </br>

 </br>
 
## 2. 직렬화 구현을 위한 다양한 상황들
- 데이터 레이아웃 : 오브젝트가 소유한 다양한 데이터를 변환할 것인가?
- 이식성 : 서로 다른 시스템에 전송해도 이식될 수 있는가?
- 버전 관리 : 새로운 기능이 추가될 때 이를 어떻게 확장하고 처리할 것인가?
- 성능 : 네트웍 비용을 줄이기 위해 어떤 데이터 형식을 사용할 것인가? (ex 양자화)
- 보안 : 데이터를 어떻게 안전하게 보호할 것인가?
- 에러 처리 : 전송 과정에서 문제가 생길 경우 이를 어떻게 인식하고 처리할 것인가?

 </br>
 
## 3. 직렬화 시스템을 위한 여러 클래스와 연산자
직렬화 시스템을 위해 제공하는 클래스 FArchive와 연산자
- 아카이브 클래스 (FArchive)
- Shift(<<)operator

다양한 아카이브 클래스의 제공
- 메모리 아카이브(FMemoryReader. FMemoryWriter)
- 파일 아카이브(FArchivFileReaderGeneric, FArchiveFileWriterGeneric)
- 기타 언리얼 오브젝트와 관련된 아카이브 클래스(FArchiveUObject)

 </br>
 
## 4. Json 직렬화
웹 환경에서 서버와 클라이언트 사이에 데이터를 주고받을 때 사용하는 텍스트 기반 데이터 포맷
장점
- 텍스트임에도 데이터 크기가 가벼움
- 읽기 편해서 데이터를 보고 이해할 수 있음
- 사실 상 웹 통신의 표준으로 널리 사용됨

단점
- 지원하는 타임이 몇가지 안됨 (문자, 숫자, 불리언, 널, 배열, 오브젝트만 가능)
- 텍스트 형식으로만 사용할 수 있음

 </br>
 
## 5. Json형식
오브젝트 : {}
- 오브젝트는 내 데이터는 키, 밸류 조합으로 구성됨 ex){ "Key":10 }

배열 : []
- 배열 내 데이터는 밸류로만 구성됨 ex)[ "value1","value2","value3"]

이외 데이터
- 문자열("string"), 숫자 (10 또는 3.14), 불리언(true 또는 false), 널(null)로 구성

 </br>
 
## 6. 언리얼 스마트 포인터 라이브러리
일반 C++오브젝트의 포인터 문제를 해결해주는 언리얼 엔진의 라이브러리 </br>

TUniquePtr(유니크포인터) : 지정한 곳에서만 메모리를 관리하는 포인터
- 특정 오브젝트에게 명확하게 포인터 해지 권한을 주고 싶은 경우
- delete구문 없이 함수 실행 후 자동으로 소멸시키고 싶을 때

TSharedPtr(공유포인터) : 더 이상 사용되지 않으면 자동으로 메모리를 해지하는 포인터
- 여러 로직에서 할당된 오브젝트가 공유해서 사용되는 경우
- 다른 함수로부터 할당된 오브젝트를 Out으로 받는 경우
- Null일 수 있음

TSharedRef(공유레퍼런스) : 공유포인터와 동일하지만, 유효한 객체를 항상 보장받는 레퍼런스
- 여러 로직에서 할당된 오브젝트가 공유해서 사용되는 경우
- Not Null을 보장받으며 오브젝트를 편리하게 사용하고 싶은 경우
